<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: structures/Registry.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: structures/Registry.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require('path');
const Command = require('./Command.js');
const Group = require('./Group.js');
const TypeReader = require('./TypeReader.js');
const Constants = require('../utility/Constants.js');
const LibraryHandler = require('../utility/LibraryHandler.js');
const requireAll = require('../utility/RequireAll.js');

/**
 * A registry containing all commands, groups and type readers.
 * @prop {Command[]} commands All registered commands.
 * @prop {Group[]} groups All registered groups.
 * @prop {TypeReader[]} typeReaders All registered type readers.
 * @prop {string} library The library being used.
 */
class Registry {
  /**
   * @typedef {object} RegistryOptions The registry options.
   * @prop {string?} library The library of the registry.
   */

  /**
   * @param {RegistryOptions} options The registry options.
   */
  constructor(options) {
    this.commands = [];
    this.groups = [];
    this.typeReaders = [];
    this.library = options !== undefined &amp;&amp; options.library !== undefined ? options.library : 'discord.js';
    this.libraryHandler = new LibraryHandler({ library: this.library });

    this.constructor.validateRegistry(this);
    requireAll(path.join(__dirname, '/../extensions/' + this.library));
  }

  /**
   * Registers all default type readers.
   * @returns {Registry} The registry being used.
   */
  registerDefaultTypeReaders() {
    this.registerTypeReadersIn(path.join(__dirname, '/../readers/' + this.library));
    return this.registerTypeReadersIn(path.join(__dirname, '/../readers/global'));
  }

  /**
   * Registers all type readers in a specific directory.
   * @param {string} directory The directory containing the type readers to be registered.
   * @returns {Registry} The registry being used.
   */
  registerTypeReadersIn(directory) {
    const obj = requireAll(directory);
    const typeReaders = [];

    for (const key in obj) {
      if (obj.hasOwnProperty(key) === true) {
        typeReaders.push(obj[key]);
      }
    }

    return this.registerTypeReaders(typeReaders);
  }

  /**
   * Registers an array of type readers.
   * @param {TypeReader[]} typeReaders An array of type readers to register.
   * @returns {Registry} The registry being used.
   */
  registerTypeReaders(typeReaders) {
    if (Array.isArray(typeReaders) === false) {
      throw new TypeError('TypeReaders must be an array.');
    }

    for (let i = 0; i &lt; typeReaders.length; i++) {
      if (typeof typeReaders[i] !== 'object') {
        throw new TypeError('All type reader exports must be an instance of the type reader.');
      } else if ((typeReaders[i] instanceof TypeReader) === false) {
        throw new Error('All type readers must be inherit the TypeReader class.');
      } else if (this.typeReaders.some((v) => v.type === typeReaders[i].type)) {
        throw new Error('The ' + typeReaders[i].type + ' type reader already exists.');
      }

      this.typeReaders.push(typeReaders[i]);
    }

    return this;
  }

  /**
   * Registers all groups in a specific directory.
   * @param {string} directory The directory containing the groups to be registered.
   * @returns {Registry} The registry being used.
   */
  registerGroupsIn(directory) {
    const obj = requireAll(directory);
    const groups = [];

    for (const key in obj) {
      if (obj.hasOwnProperty(key) === true) {
        groups.push(obj[key]);
      }
    }

    return this.registerGroups(groups);
  }

  /**
   * Registers an array of groups.
   * @param {Group[]} groups An array of groups to be registered.
   * @returns {Registry} The registry being used.
   */
  registerGroups(groups) {
    if (Array.isArray(groups) === false) {
      throw new TypeError('Groups must be an array.');
    }

    for (let i = 0; i &lt; groups.length; i ++) {
      if (typeof groups[i] !== 'object') {
        throw new TypeError('All group exports must be an instance of the group.');
      } else if ((groups[i] instanceof Group) === false) {
        throw new Error('All groups must inherit the Group class.');
      } else if (this.groups.some((v) => v.name === groups[i].name) === true) {
        throw new Error('The ' + groups[i].name + ' group already exists.');
      }

      this.groups.push(groups[i]);
    }

    return this;
  }

  /**
   * Registers all commands in a specific directory.
   * @param {string} directory The directory containing the commands to be registered.
   * @returns {Registry} The registry being used.
   */
  registerCommandsIn(directory) {
    const obj = requireAll(directory);
    const commands = [];

    for (const groupKey in obj) {
      if (obj.hasOwnProperty(groupKey) === true) {
        const groupIndex = this.groups.findIndex((v) => v.name === groupKey);

        if (groupIndex === -1) {
          throw new Error('The ' + groupKey + ' group is not registered. All commands must be placed inside a respective folder of their group inside the main commands folder.');
        }

        for (const commandKey in obj[groupKey]) {
          if (obj[groupKey].hasOwnProperty(commandKey) === true) {
            commands.push(obj[groupKey][commandKey]);
            obj[groupKey][commandKey].group = this.groups[groupIndex];
            this.groups[groupIndex].commands.push(obj[groupKey][commandKey]);
          }
        }
      }
    }

    return this.registerCommands(commands);
  }

  /**
   * Registers an array of commands.
   * @param {Command[]} commands An array of commands to register.
   * @returns {Registry} The registry being used.
   */
  registerCommands(commands) {
    if (Array.isArray(commands) === false) {
      throw new TypeError('Commands must be an array.');
    }

    for (let i = 0; i &lt; commands.length; i ++) {
      if (typeof commands[i] !== 'object') {
        throw new TypeError('All command exports must be an instance of the command.');
      } else if ((commands[i] instanceof Command) === false) {
        throw new Error('All commands must inherit the Command class.');
      }

      for (let j = 0; j &lt; commands[i].names.length; j++) {
        if (this.commands.some((x) => x.names.some((y) => y === commands[i].names[j])) === true) {
          throw new Error('A command with the name ' + commands[i].names[j] + ' is already registered.');
        }
      }

      for (let j = 0; j &lt; commands[i].args.length; j++) {
        const typeReader = this.typeReaders.find((x) => x.type === commands[i].args[j].type);

        if (typeReader === undefined) {
          throw new Error('The ' + commands[i].args[j].type + ' type does not exist.');
        }

        commands[i].args[j].typeReader = typeReader;
      }

      this.commands.push(commands[i]);
    }

    return this;
  }

  /**
   * Validates the registry.
   * @param {Registry} registry The registry to validate.
   * @private
   */
  static validateRegistry(registry) {
    if (typeof registry.library !== 'string' || registry.library !== registry.library.toLowerCase()) {
      throw new TypeError('The library must be a lowercase string.');
    } else if (Constants.libraries.indexOf(registry.library) === -1) {
      throw new TypeError(registry.library + ' isn\'t a supported library.');
    }
  }
}

module.exports = Registry;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Argument.html">Argument</a></li><li><a href="ArgumentPrecondition.html">ArgumentPrecondition</a></li><li><a href="Command.html">Command</a></li><li><a href="CooldownResult.html">CooldownResult</a></li><li><a href="ExceptionResult.html">ExceptionResult</a></li><li><a href="Group.html">Group</a></li><li><a href="Handler.html">Handler</a></li><li><a href="Precondition.html">Precondition</a></li><li><a href="PreconditionResult.html">PreconditionResult</a></li><li><a href="Registry.html">Registry</a></li><li><a href="Result.html">Result</a></li><li><a href="TypeReader.html">TypeReader</a></li><li><a href="TypeReaderResult.html">TypeReaderResult</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ArgumentDefault">ArgumentDefault</a></li><li><a href="global.html#CommandError">CommandError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Oct 26 2017 14:05:49 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
